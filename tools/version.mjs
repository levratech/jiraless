#!/usr/bin/env node
/**
 * Jiraless - UI Version Bumper + Health emitter
 * - Bumps patch in ui/package.json unless VERSION_BUMP=none
 * - Writes ui/src/version.ts (APP_VERSION, BUILD_TIME_UTC, GIT_SHA)
 * - Writes ui/public/version.json
 * - Writes ui/public/health.txt and ui/public/health.json
 */
import fs from "fs/promises";
import fsSync from "fs";
import path from "path";
import { execSync } from "child_process";

const UI_DIR = "ui";
const PKG = path.join(UI_DIR, "package.json");
const VERSION_TS = path.join(UI_DIR, "src/version.ts");
const VERSION_JSON = path.join(UI_DIR, "public/version.json");
const HEALTH_TXT = path.join(UI_DIR, "public/health.txt");
const HEALTH_JSON = path.join(UI_DIR, "public/health.json");

function stampUTC() {
  const d = new Date();
  const pad = (n) => String(n).padStart(2, "0");
  return (
    d.getUTCFullYear() +
    pad(d.getUTCMonth() + 1) +
    pad(d.getUTCDate()) +
    "." +
    pad(d.getUTCHours()) +
    pad(d.getUTCMinutes())
  );
}

function buildTimeUTC() {
  return new Date().toISOString();
}
function bumpPatch(v) {
  const core = v.split("-")[0].split("+")[0];
  const [maj, min, pat] = core.split(".").map((x) => parseInt(x, 10) || 0);
  return `${maj}.${min}.${(pat ?? 0) + 1}`;
}
async function writeIfChanged(file, content) {
  try {
    const prev = await fs.readFile(file, "utf8");
    if (prev === content) return false;
  } catch {}
  await fs.mkdir(path.dirname(file), { recursive: true });
  await fs.writeFile(file, content, "utf8");
  return true;
}

function gitSha() {
  try {
    return process.env.GITHUB_SHA || execSync("git rev-parse HEAD").toString().trim();
  } catch {
    return "unknown";
  }
}

async function readProductVersion() {
  try {
    const content = await fs.readFile("PRODUCT_VERSION", "utf8");
    return content.trim();
  } catch {
    return "";
  }
}

async function main() {
  const bumpMode = process.env.VERSION_BUMP || "patch"; // 'patch' | 'none'
  const repo = process.env.GITHUB_REPOSITORY || "";

  const pkg = JSON.parse(await fs.readFile(PKG, "utf8"));
  let newVersion = pkg.version || "0.0.0";
  if (bumpMode !== "none") {
    newVersion = bumpPatch(newVersion);
    pkg.version = newVersion;
    await fs.writeFile(PKG, JSON.stringify(pkg, null, 2) + "\n", "utf8");
    console.log("Bumped ui/package.json version to", newVersion);
  } else {
    console.log("VERSION_BUMP=none â†’ not bumping ui/package.json; using", newVersion);
  }

  const stamp = stampUTC();
  const buildTimeIso = buildTimeUTC();
  const sha = gitSha();
  const productVersion = await readProductVersion();
  const appVersion = `${newVersion}+${stamp}`;

  const ts = `// Auto-generated by tools/version.mjs
export const APP_VERSION = ${JSON.stringify(appVersion)};
export const BUILD_TIME_UTC = ${JSON.stringify(buildTimeIso)};
export const GIT_SHA = ${JSON.stringify(sha)};
export const PRODUCT_VERSION = ${JSON.stringify(productVersion)};
`;
  await writeIfChanged(VERSION_TS, ts);

  const vjsonObj = { 
    app_version: appVersion, 
    build_time_utc: buildTimeIso, 
    git_sha: sha, 
    repo: repo,
    product_version: productVersion || undefined
  };
  // Remove undefined values
  Object.keys(vjsonObj).forEach(key => vjsonObj[key] === undefined && delete vjsonObj[key]);
  await writeIfChanged(VERSION_JSON, JSON.stringify(vjsonObj, null, 2));

  const healthTxt = [
    "ok",
    `version=${appVersion}`,
    `package=${newVersion}`,
    `built_utc=${stamp}`,
    `git_sha=${sha}`,
    repo ? `repo=${repo}` : null,
  ].filter(Boolean).join("\n") + "\n";
  await writeIfChanged(HEALTH_TXT, healthTxt);
  await writeIfChanged(HEALTH_JSON, JSON.stringify({ status: "ok", ...vjsonObj }, null, 2));

  console.log("Wrote", VERSION_TS, VERSION_JSON, HEALTH_TXT, HEALTH_JSON);
}
main().catch((e) => { console.error(e); process.exit(1); });